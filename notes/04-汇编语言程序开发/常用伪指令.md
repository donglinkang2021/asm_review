## 常用伪指令



### 数据定义伪指令

数据定义伪指令用来定义程序中使用的数据

| 格式 | 功能 | 
| :--: | :--: |
| [变量名] 助记符 操作数 | 为变量分配单元，并为其初始化或者只预留空间 |

<details>
<summary>变量名是可选的，需要时由用户自己起。</summary>

- 它是该数据区的符号地址，
- 也是其中第一个数据项的偏移量。
- 程序通过变量名引用其中的数据。
</details>

<details>
<summary>助记符是数据类型的符号表示。</summary>

| 助记符 | 数据类型 | 一个数据项字节数 |
| :----: | :------: | :--------------: |
|  DB *BYTE*  | 字节型 |         1          |
|  DW *WORD*  | 字型 |         2          |
|  DD *DWORD*  | 双字型 |         4          |
|  DQ *QWORD*  | 四字型 |         8          |
|  DF *FWORD*  | 六字节型 |         6          |
|  DT *TBYTE*  | 10字节型 |         10          |

注：必须掌握DB、DW、DD

</details>

操作数可以是下面这些

<details>
<summary>数字常量及数值表达式</summary>

操作数可以是数值表达式，数字中若出现字母形式,不区分大小写。如下所示：

- **十进制数** ：以D结尾，汇编语言中缺省值是十进制数，所以D可以省略不写。
- **二进制数** ：以B结尾。例如，10100011B，10100011b。
- **十六进制数** ：以H结尾。例如，12H，12h，0AB56H，0ab56h。
- **八进制数** ：以Q或O（字母）结尾。例如，352Q。

</details>

<details>
<summary>字符串常量</summary>

在汇编语言中字符需要用**单引号括起来**，

- 其值为字符的ASCII值。
- 因为每个字符占用一个字节，所以最好用**DB助记符**定义字符串。
  - 例如，`'A'`的值为41H。`'abc'`的值为616263H。

</details>

<details>
<summary>地址表达式</summary>

操作数可以是地址符号。

- 若只定义符号的偏移量部分，则使用DW助记符。
- 若要定义它的双字长地址指针（既含16位**偏移量**又含**段基址**），则使用DD助记符，
  - 其中低字中存放偏移量，高字中存放段基址。
  - 例如,`VAR DW LAB`语句在汇编后`VAR`中含有`LAB`的偏移量

</details>

<details>
<summary><code>?</code>表示未初始化的数据</summary>

- 在程序中使用`?`为变量预留空间而不赋初值。

</details>

<details>
<summary><code><n> DUP (操作数, ...)</code>形式</summary>

- 若要对某些数据重复多次，可以使用这种格式。
  - 其功能是把`()`中的内容复制n次。
- DUP可以嵌套。

</details>



### 符号定义伪指令

> 汇编后该符号代表一个确定的值

| 格式 | 功能 | 说明 | 注意 |
| :--: | :--: | :--: | :--: |
|  `符号名 EQU 表达式`  | 用符号名代表表达式或表达式的值 | 表达式可以是任何有效的操作数格式。例如常数、数值表达式、另一符号名或助记符 | 用EQU定义的符号在同一个程序中不能再定义 |
|  `符号名 = 表达式`  | 用符号名代替数值表达式的值 | 等号伪指令与EQU伪指令功能相似,其区别是<font color=red>等号伪指令的表达式只能是常数或数值表达式</font>。| 用`=`定义的符号在同一个程序中可以再定义。通常在程序中用`=`定义常数 |

- 这两个伪指令都是用定义内容对定义符号进行简单替换，不会进行语法检查。

### 操作符伪指令

> 从程序的第一行到最后一行，地址计数器在不断地增加。

操作符可以出现在语句的操作数表达式中。该操作在汇编程序汇编时实现。包括**算术、逻辑、关系、属性、返回值**操作符。



<details>
<summary>1. <code>$</code>操作符</summary>

- `$`操作符用来表示当前语句的偏移量。
- 程序中一般不直接使用`$`的值，而是使用它来计算变量占用的空间

```asm
; 例子
wVar WORD 0102h, 1000, 100*100
BYTESOFWVAR EQU $ - wVar ;值等于6
```

</details>

<details>
<summary>2. <code>OFFSET</code>操作符</summary>

| 格式 | 功能 |
| :--: | :--: |
|  `OFFSET [变量\|标号]`  | OFFSET操作符用来取出变量或标号的地址（在段中的偏移量）。在32位编程环境中，地址是一个32位的数。 |

```asm
; 例子
mov ax, OFFSET wVar ;将wVar的偏移量送入ax
```

</details>

<details>
<summary>3. 算术操作符</summary>

- 算术操作符可以用在**数值表达式**或**地址表达式**中

| 操作符 | 功能 |
| :----: | :--: |
|  `+`  | 加法 |
|  `-`  | 减法 |
|  `*`  | 乘法 |
|  `/`  | 除法 |
|  `MOD`  | 取模 |

```asm
; 例子
X DW 12, 34, 56
CT EQU ($ - X) / 2 ;CT的值为3
MOV CX, CT ;CX的值为3
MOV AX, X ;AX的值为12
ADD AX, X + 2 ;AX的值为46 (12 + 34, 因为是字型，所以加2)
```
</details>

<details>
<summary>4. 逻辑操作符</summary>

| 操作符 | 功能 |
| :----: | :--: |
|  `NOT`  | 按位取反 |
|  `AND`  | 按位与 |
|  `OR`  | 按位或 |
|  `XOR`  | 按位异或 |

```asm
; 例子
PORT EQU 0FH
AND DL, PORT AND 0FEH ; 0FH AND 0FEH = 0EH

; 汇编后我们得到
AND DL, 0EH
```

</details>

<details>
<summary>5. 关系操作符</summary>

| 操作符 | 功能 |
| :----: | :--: |
|  `EQ`  | 等于 |
|  `NE`  | 不等于 |
|  `GT`  | 大于 |
|  `GE`  | 大于等于 |
|  `LT`  | 小于 |
|  `LE`  | 小于等于 |

```asm
; 指令 MOV AL,CH LT 20的汇编结果：
MOV AL, 0FFH ; CH < 20
; 或者
MOV AL, 0 ; CH >= 20
```

</details>


### 框架定义伪指令

较常使用的选择微处理器伪指令有以下几种

| 伪指令 | 功能 |
| :----: | :--: |
|  `.286`  | 选择80286微处理器指令系统 |
|  `.386`  | 选择80386微处理器指令系统 |
|  `.486`  | 选择80486微处理器指令系统 |
|  `.586`  | 选择Pentium微处理器指令系统 |
|  `.8087`  | 选择8087协处理器指令系统 |
|  `.287`  | 选择80287协处理器指令系统 |
|  `.387`  | 选择80387协处理器指令系统 |

| 伪指令格式 | 功能 |
| :----: | :--: |
| `.DATA` | 定义数据段 |
| `.DATA?` | 定义存放未初始化变量的数据段 |
| `.CONST` | 定义存放常量的数据段 |
| `.CODE` | 定义代码段 |
| `.STARTUP` | 定义程序开始执行的入口点 |
| `.EXIT` | 返回DOS或父进程 |
| `.STACK size` | 建立一个堆栈段并定义其大小（size以字节为单位。若不指定size参数，则使用默认值1 KB） |
| `.MODEL 内存模式[,调用规则][,其他模式]` | 定义程序工作的模式 |


#### 简化指令

<details>
<summary>定义存储模型伪指令</summary>

| 常用格式 | 功能 |
| :----: | :--: |
| `.model 存储模型` | 定义存储模型 |

常用的存储模型有：

| 存储模型 | 功能 |
| :----: | :--: |
| `TINY` | 所有代码和数据放置在一个段中 |
| `SMALL` | 所有代码在一个段内,所有数据在另一个段 |
| `MEDIUM` | 代码放置在多个段内。数据限制在一个段 |
| `COMPACT` | 代码在一个段内，数据可以在多个段内 |
| `LARGE` | 代码和数据被放置在多个段内 |
| `HUGE` | 单个数据项可以超过64K,其它同LARGE模型 |
| `FLAT` | 与TINY模型类似，所有代码和数据放置在一个段中。TINY模型的段是16位，FLAT32位 |

</details>

<details>
<summary>定义堆栈段尺寸伪指令</summary>

| 常用格式 | 功能 | 说明 |
| :----: | :--: | :--: |
| `.stack size` | 建立一个堆栈段并定义其大小 | 若不指定size参数，则使用缺省值1KB |

</details>